== Yamaledt -- JUnit 5 Parameterized Tests Using Yaml and Jamal

=== Introduction and usage

You can create parameterized unit tests fetching the data from Yaml formatted resource file using Yamaledt.
To use the possibility add the dependency to your build configuration.
In case of Maven, for example, add the following lines to your `dependencies` configuration part:

{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}\

[source,xml]
----
<dependency>
    <groupId>com.javax0.yamaledt</groupId>
    <artifactId>yamaledt</artifactId>
    <version>{%VERSION%}</version>
    <scope>test</scope>
</dependency>
----

The next step is to create a parameterized test, and the Yaml file that holds the data set for the tests.

{%@snip:collect from=./src/test/java/%}

[source,java]
----
{%@snip sampleTestWithSimpleParameters%}
----

The JUnit 5 annotation {%@java:class (format=`@$simpleName`) org.junit.jupiter.params.ParameterizedTest%} signals that this test is a parameterized test.
The annotation {%@java:class (format=`@$simpleName`) javax0.yamaledt.YamlSource%} specifies the test data source.
In this case all the settings are the default, there are no arguments.
The data will be read from the resource file {%@java:method (format=`$name.yaml`) javax0.yamaledt.TestYamalArgumentProvider#sampleTestWithSimpleParameters%}.
The name is calculated from the name of the test method and the extension `.yaml` is appended to it.

NOTE: The extension by default is `.yaml.jam`.
In the example above we disabled the Jamal processing and therefore the default extension became `.yaml`.
Using Jamal macros in the test data file is an advanced topic.
We do not detail it in the introduction section.

The Yaml data source file contains the data in the format:

[source,yaml]
----
{%@include [verbatim] src/test/resources/javax0/yamaledt/sampleTestWithSimpleParameters.yaml%}
----

The Yaml file describes a Map structure.
The keys are the test names.
These are the strings that will get into the place of the strings, which are defined using the {%@java:class (format=`@$simpleName`)org.junit.jupiter.api.DisplayName%} annotation in non-parameterized tests.
The value for each key/test is also a Map specifying the values for the test parameters.

The mapping of values can be based on

* the type of the method arguments, or

* the value of the annotation {%@java:class (format=`@$simpleName`)javax0.yamaledt.Name%}.

In the example above we have three parameters.

* One is named using {%@java:class (format="`@$simpleName(\"DisplayName\")`") javax0.yamaledt.Name%},

* one unnamed, and

* one named using {%@java:class (format="`@$simpleName(\"k\")`") javax0.yamaledt.Name%}.

In the Yaml file the main key, is used for the parameter named 'DisplayName'.
For the unnamed parameter the type is used, which is, in this case is `int`.
Finally, the last parameter gets the value from the map using the key `k`.

Running this test from an IDE will result a view something like this:

image::images/idea_sample_run.png[]

=== Annotation {%@java:class (format="`@$simpleName`") javax0.yamaledt.YamlSource%}

The annotation {%@java:class (format="`@$simpleName`") javax0.yamaledt.YamlSource%} is used to specify parameters for the test.
You have to use it together with the annotation {%@java:class (format=`@$simpleName`) org.junit.jupiter.params.ParameterizedTest%}.
The parameters of the annotation are:

* `value` may specify the file that holds the test data.
If it is not specified then the name of the name of the test method will be used with the extension `.yaml.jam` or `.yaml`.
The extension `.yaml.jam` is used by default.
The extension `.yaml` is used when the `@Jamal` annotation `enabled=false` disables the Jamal processing.
If there is a specified value, then the value is used as a resource name, and no extension is appended to the name.
That way you have to specify {%@java:class (format="`@$simpleName(\"testData.yaml\")`") javax0.yamaledt.YamlSource%}.

* `jamal` may specify a `@Jamal` annotation.
The use of this parameter is not recommended.
The same result can be achieved adding the `@Jamal` annotation directly on the test method or on the class containing the test method.

=== Annotation {%@java:class (format="`@$simpleName`") javax0.yamaledt.Jamal%}

The annotation {%@java:class (format="`@$simpleName`") javax0.yamaledt.Jamal%} is used to specify parameters for the input Jamal processing.

Jamal is a general purpose text preprocessor that can go to extreme to eliminate input redundancy and copy-paste.
This way the data structures that appear repeatedly in the test data structure can be described programmatically.
Jamal supports Yaml data structure handling through an extension module, and the Jamal transformation process can be debugged via Web user interface.
The core Jamal modules as well as the debugger module, yaml and snippet handling modules are included in the project dependencies.
If you want to use any other module you need to add those to the project as a dependency.

For more information about Jamal read the documentation at https://github.com/verhas/jamal

The parameters of the annotation are

* `open` can specify the macro opening string.
This is {%@escape `` `{%` ``%} by default.

* `close` can specify the macro closing string
This is {%@escape `` `%}` ``%} by default.

* `enabled` can be used to disable Jamal processing on the input.
The default is to interpret the input as a macro text that results Yaml as output.
Use `@Jamal(enabled=false)` annotation on the method to disample Jamal processing.
When Jamal processing is disabled the default file name extension will be `.yaml` when the parameter resource name is calculated from the method name.

* `dump` can be used to specify a file name where the output of the Jamal processing in written.
This content does not need to be written into a file.
It is processed in memory usually.
This option is only provided in case you want to look at the generated, already pure Yaml formatted file.






